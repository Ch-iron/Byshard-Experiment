package config

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	//"paperexperiment/crypto"

	"paperexperiment/identity"
	"paperexperiment/log"
	"paperexperiment/transport"
	"paperexperiment/types"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

const path = "../common/"

var configFile = flag.String("config", "config.json", "Configuration file for bamboo replica. Defaults to config.json.")
var ipsFile = flag.String("ips", "ips.txt", "Ips for validators nodes. Defaults to ips.txt")
var baseIpsFile = flag.String("baseIPs", "base_ips.txt", "Ips for base chain validators nodes. Defaults to ips.txt")
var addressFile = flag.String("address", "address.txt", "Address for test. Defaults to address.txt")

// Config contains every system configuration
type Config struct {
	Addrs     map[types.Shard]map[identity.NodeID]string `json:"address"`      // address for node communication
	HTTPAddrs map[identity.NodeID]string                 `json:"http_address"` // address for client server communication

	Policy    string  `json:"policy"`    // leader change policy {consecutive, majority}
	Threshold float64 `json:"threshold"` // threshold for policy in WPaxos {n consecutive or time interval in ms}

	Thrifty           bool            `json:"thrifty"`          // only send messages to a quorum
	BufferSize        int             `json:"buffer_size"`      // buffer size for maps
	ChanBufferSize    int             `json:"chan_buffer_size"` // buffer size for channels
	MultiVersion      bool            `json:"multiversion"`     // create multi-version database
	Timeout           int             `json:"timeout"`
	ViewChangeTimeout int             `json:"viewchange_timeout"`
	ByzNo             int             `json:"byzNo"`
	BSize             int             `json:"bsize"`
	Fixed             bool            `json:"fixed"`
	Benchmark         Bconfig         `json:"benchmark"` // benchmark configuration
	Delta             int             `json:"delta"`     // timeout, seconds
	Pprof             bool            `json:"pprof"`
	MaxRound          int             `json:"maxRound"`
	Strategy          string          `json:"strategy"`
	PayloadSize       int             `json:"payload_size"`
	Master            identity.NodeID `json:"master"`
	Delay             int             `json:"delay"` // transmission delay in ms
	DErr              int             `json:"derr"`  // the err taken into delays
	MemSize           int             `json:"memsize"`
	Slow              int             `json:"slow"`
	Crash             int             `json:"crash"`

	LockingDegree    int    `json:"locking_degree"`
	ShardCount       int    `json:"shard_count"`
	DefaultBalance   int    `json:"default_balance"`
	ClientNumber     int    `json:"client_number"`
	ViewChangePeriod int    `json:"viewchange_period"`
	CommitteeNumber  int    `json:"committee_number"`
	RotatingElection string `json:"rotating_election"`
	InShardLatency   int    `json:"inshardlatency"`
	Shard12Latency   int    `json:"shard12latency"`
	Shard13Latency   int    `json:"shard13latency"`
	Shard23Latency   int    `json:"shard23latency"`

	hasher string
	signer string

	// for future implementation
	// Batching bool `json:"batching"`
	// Consistency string `json:"consistency"`
	// Codec string `json:"codec"` // codec for message serialization between nodes

	n     int // total number of nodes
	nBase int // total number of nodes of base shard
}

// Bconfig holds all benchmark configuration
type Bconfig struct {
	T            int    // total number of running time in seconds
	N            int    // total number of requests
	K            int    // key sapce
	Throttle     int    // requests per second throttle, unused if 0
	Concurrency  int    // number of simulated clients
	Distribution string // distribution
	// rounds       int    // repeat in many rounds sequentially

	// conflict distribution
	Conflicts int // percentage of conflicting keys
	Min       int // min key

	// normal distribution
	Mu    float64 // mu of normal distribution
	Sigma float64 // sigma of normal distribution
	Move  bool    // moving average (mu) of normal distribution
	Speed int     // moving speed in milliseconds intervals per key

	TXRatioPerType []int
	ZipfTheta      float64
}

type CAwithExternalAddress struct {
	CA                  common.Address
	ExternalAddressList []common.Address
}

// Config is global configuration singleton generated by init() func below
var Configuration Config

func init() {
	Configuration = MakeDefaultConfig()
}

func GetAddresses() []*common.Address {
	addresses, err := os.ReadFile(path + "address.txt")
	if err != nil {
		panic(err)
	}
	addr_array_string := strings.Split(string(addresses), "\n")
	addr_array := make([]*common.Address, 0)
	for i := 0; i < len(addr_array_string); i++ {
		stringtoaddress := common.HexToAddress(addr_array_string[i])
		addr_array = append(addr_array, &stringtoaddress)
	}
	return addr_array
}

// GetConfig returns paxi package configuration
func GetConfig() Config {
	return Configuration
}

func GetTimer() time.Duration {
	return time.Duration(time.Duration(Configuration.Timeout) * time.Millisecond)
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

// GetDeployCode returns contract deploycode for train, hotel, travel contract
func GetDeployCode(contractName string, code []byte, arg1 string, arg2 string) []byte {
	switch contractName {
	case "payment":
		return hexutil.MustDecode("0x" + string(code))
	case "train":
		return hexutil.MustDecode("0x" + string(code))
	case "hotel":
		return hexutil.MustDecode("0x" + string(code))
	case "travel":
		return hexutil.MustDecode("0x" + string(code) + "000000000000000000000000" + arg1 + "000000000000000000000000" + arg2)
	}
	return nil
}

// GetCA returns contract address for travel, train, hotel contract
func GetCA(shard types.Shard) (travelnormalCAs, trainnormalCAs, hotelnormalCAs, travelcrossCAs, traincrossCAs, hotelcrossCAs []common.Address, travelcrossParams [][]common.Address) {
	trainnormalCAs = make([]common.Address, 0, 10000)
	hotelnormalCAs = make([]common.Address, 0, 10000)
	travelnormalCAs = make([]common.Address, 0, 10000)
	travelcrossCAs = make([]common.Address, 0, 10000)
	traincrossCAs = make([]common.Address, 0, 10000)
	hotelcrossCAs = make([]common.Address, 0, 10000)
	travelcrossParams = make([][]common.Address, 10000)

	path := "../common/ca/"

	finalPath := fmt.Sprintf("%v%v/normal.txt", path, shard)
	normalCA, err := os.ReadFile(finalPath)
	check(err)
	for idx, ca := range strings.Split(string(normalCA), "\n") {
		if idx >= 10000 {
			break
		}
		CAs := strings.Split(ca, ",")
		travelnormalCAs = append(travelnormalCAs, common.HexToAddress(CAs[0]))
		trainnormalCAs = append(trainnormalCAs, common.HexToAddress(CAs[1]))
		hotelnormalCAs = append(hotelnormalCAs, common.HexToAddress(CAs[2]))
	}

	crossCA1, err := os.ReadFile(path + "1/cross.txt")
	check(err)
	crossCA2, err := os.ReadFile(path + "2/cross.txt")
	check(err)
	crossCA3, err := os.ReadFile(path + "3/cross.txt")
	check(err)

	switch shard {
	case 1:
		for idx, ca := range strings.Split(string(crossCA1), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossCAs = append(travelcrossCAs, common.HexToAddress(CAs[0]))
			traincrossCAs = append(traincrossCAs, common.HexToAddress(CAs[1]))
			hotelcrossCAs = append(hotelcrossCAs, common.HexToAddress(CAs[2]))
		}
		for idx, ca := range strings.Split(string(crossCA2), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParam := make([]common.Address, 2)
			travelcrossParam[0] = common.HexToAddress(CAs[1])
			travelcrossParams[idx] = travelcrossParam
		}
		for idx, ca := range strings.Split(string(crossCA3), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParams[idx][1] = common.HexToAddress(CAs[2])
		}
	case 2:
		for idx, ca := range strings.Split(string(crossCA2), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossCAs = append(travelcrossCAs, common.HexToAddress(CAs[0]))
			traincrossCAs = append(traincrossCAs, common.HexToAddress(CAs[1]))
			hotelcrossCAs = append(hotelcrossCAs, common.HexToAddress(CAs[2]))
		}
		for idx, ca := range strings.Split(string(crossCA3), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParam := make([]common.Address, 2)
			travelcrossParam[0] = common.HexToAddress(CAs[1])
			travelcrossParams[idx] = travelcrossParam
		}
		for idx, ca := range strings.Split(string(crossCA1), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParams[idx][1] = common.HexToAddress(CAs[2])
		}
	case 3:
		for idx, ca := range strings.Split(string(crossCA3), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossCAs = append(travelcrossCAs, common.HexToAddress(CAs[0]))
			traincrossCAs = append(traincrossCAs, common.HexToAddress(CAs[1]))
			hotelcrossCAs = append(hotelcrossCAs, common.HexToAddress(CAs[2]))
		}
		for idx, ca := range strings.Split(string(crossCA1), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParam := make([]common.Address, 2)
			travelcrossParam[0] = common.HexToAddress(CAs[1])
			travelcrossParams[idx] = travelcrossParam
		}
		for idx, ca := range strings.Split(string(crossCA2), "\n") {
			if idx >= 10000 {
				break
			}
			CAs := strings.Split(ca, ",")
			travelcrossParams[idx][1] = common.HexToAddress(CAs[2])
		}
	}

	return travelnormalCAs, trainnormalCAs, hotelnormalCAs, travelcrossCAs, traincrossCAs, hotelcrossCAs, travelcrossParams
}

func GetRwSet(contractName string) map[string]types.RwSet {
	var rwSetJSON []types.RwData
	rwSet := make(map[string]types.RwSet)
	rwSetFile, err := os.ReadFile("../common/contracts/" + contractName + "/rwSet.json")
	if err != nil {
		panic(err)
	}
	err = json.Unmarshal(rwSetFile, &rwSetJSON)
	check(err)

	for _, rwData := range rwSetJSON {
		rwSet[rwData.FunctionSelector] = types.RwSet{
			ReadSet:     rwData.ReadSet,
			WriteSet:    rwData.WriteSet,
			ExternalSet: rwData.ExternalRweSet,
		}
	}
	return rwSet
}

func GetAbi() abi.ABI {
	abiFile, _ := os.ReadFile(("../common/contracts/travel/travel.abi"))
	abiObj, _ := abi.JSON(strings.NewReader(string(abiFile)))
	return abiObj
}

func GetRandomIntUnder(n int) int {
	rand.NewSource(time.Now().UnixNano())
	return rand.Intn(n)
}

func GetTravelCA(caType string, shard types.Shard) []CAwithExternalAddress {
	travelCAwithExternalAddress := make([]CAwithExternalAddress, 0)

	dir := "../common/ca/"

	if caType == "normal" {
		travelCAs, err := os.ReadFile(fmt.Sprintf("%v%v/%v.txt", dir, shard, caType))
		check(err)
		travelCAArray := strings.Split(string(travelCAs), "\n")
		for i := 0; i < len(travelCAArray)-1; i++ {
			travelCA := strings.Split(travelCAArray[i], ",")
			travelCAwithExternalAddress = append(travelCAwithExternalAddress, CAwithExternalAddress{
				CA:                  common.HexToAddress(travelCA[0]),
				ExternalAddressList: []common.Address{common.HexToAddress(travelCA[1]), common.HexToAddress(travelCA[2]), common.HexToAddress(travelCA[1]), common.HexToAddress(travelCA[2])},
			})
		}
	} else if caType == "cross" {
		crossCA1, err := os.ReadFile(fmt.Sprintf("%v1/%v.txt", dir, caType))
		check(err)
		crossCA1Array := strings.Split(string(crossCA1), "\n")
		crossCA2, err := os.ReadFile(fmt.Sprintf("%v2/%v.txt", dir, caType))
		check(err)
		crossCA2Array := strings.Split(string(crossCA2), "\n")
		crossCA3, err := os.ReadFile(fmt.Sprintf("%v3/%v.txt", dir, caType))
		check(err)
		crossCA3Array := strings.Split(string(crossCA3), "\n")
		switch shard {
		case 1:
			for i := 0; i < 10000; i++ {
				travelCA := strings.Split(crossCA1Array[i], ",")
				trainCA := strings.Split(crossCA2Array[i], ",")
				hotelCA := strings.Split(crossCA3Array[i], ",")
				travelCAwithExternalAddress = append(travelCAwithExternalAddress, CAwithExternalAddress{
					CA:                  common.HexToAddress(travelCA[0]),
					ExternalAddressList: []common.Address{common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2]), common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2])},
				})
			}
		case 2:
			for i := 0; i < 10000; i++ {
				travelCA := strings.Split(crossCA2Array[i], ",")
				trainCA := strings.Split(crossCA3Array[i], ",")
				hotelCA := strings.Split(crossCA1Array[i], ",")
				travelCAwithExternalAddress = append(travelCAwithExternalAddress, CAwithExternalAddress{
					CA:                  common.HexToAddress(travelCA[0]),
					ExternalAddressList: []common.Address{common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2]), common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2])},
				})
			}
		case 3:
			for i := 0; i < 10000; i++ {
				travelCA := strings.Split(crossCA3Array[i], ",")
				trainCA := strings.Split(crossCA1Array[i], ",")
				hotelCA := strings.Split(crossCA2Array[i], ",")
				travelCAwithExternalAddress = append(travelCAwithExternalAddress, CAwithExternalAddress{
					CA:                  common.HexToAddress(travelCA[0]),
					ExternalAddressList: []common.Address{common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2]), common.HexToAddress(trainCA[1]), common.HexToAddress(hotelCA[2])},
				})
			}
		}
	}

	return travelCAwithExternalAddress
}

// Simulation enable go channel transportation to simulate distributed environment
func Simulation() {
	*transport.Scheme = "chan"
}

// MakeDefaultConfig returns Config object with few default values
// only used by init() and master
func MakeDefaultConfig() Config {
	return Config{
		n:              4,
		ShardCount:     1,
		Policy:         "consecutive",
		Threshold:      3,
		BufferSize:     1024,
		ChanBufferSize: 1024,
		MultiVersion:   false,
		hasher:         "sha3_256",
		signer:         "ECDSA_P256",
		// Benchmark:      DefaultBConfig(),
	}
}

// IDs returns all node ids
func (c Config) IDs() []identity.NodeID {
	ids := make([]identity.NodeID, 0)
	for _, addrs := range c.Addrs {
		for id := range addrs {
			ids = append(ids, id)
		}
	}
	return ids
}

func (c Config) IDsFor(shard types.Shard) []identity.NodeID {
	ids := make([]identity.NodeID, 0)
	for id := range c.Addrs[shard] {
		ids = append(ids, id)
	}
	return ids
}

// N returns total number of nodes
func (c Config) NBase() int {
	return c.nBase
}

// N returns total number of nodes
func (c Config) N() int {
	return c.n
}

func (c Config) ClientN() int {
	return c.ClientNumber
}

func (c Config) NPerShard() int {
	return c.n / c.ShardCount
}

// GetHash returns the hashing scheme of the configuration
func (c Config) GetHashScheme() string {
	return c.hasher
}

// GetSignatureScheme returns the signing scheme of the configuration
func (c Config) GetSignatureScheme() string {
	return c.signer
}

// String is implemented to print the Configuration
func (c Config) String() string {
	config, err := json.Marshal(c)
	if err != nil {
		log.Error(err)
		return ""
	}
	return string(config)
}

// Load loads configuration from Configuration file in JSON format
func (c *Config) Load() {
	file, err := os.Open(filepath.Join(path, *configFile))
	if err != nil {
		log.Fatal(err)
	}
	decoder := json.NewDecoder(file)
	err = decoder.Decode(c)
	if err != nil {
		log.Fatal(err)
	}

	// load ips
	ip_file, err := os.Open(filepath.Join(path, *ipsFile))
	if err != nil {
		log.Fatal(err)
	}
	defer ip_file.Close()

	scanner := bufio.NewScanner(ip_file)

	s := 1
	i := 1
	for scanner.Scan() {
		id := identity.NewNodeID(i)
		// port := strconv.Itoa(3999 + i)
		addr := "tcp://" + scanner.Text() + ":"
		portHttp := strconv.Itoa(8069 + i)
		addrHttp := "http://" + scanner.Text() + ":" + portHttp
		_, exist := c.Addrs[types.Shard(s)]
		if !exist {
			c.Addrs[types.Shard(s)] = make(map[identity.NodeID]string)
		}
		c.Addrs[types.Shard(s)][identity.NewNodeID(i)] = addr
		s++
		// shard := c.GetShardNumOfId(id)
		// c.Addrs[shard][id] = addr
		c.HTTPAddrs[id] = addrHttp
		if s > c.ShardCount {
			i++
			s = 1
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
	}

	c.n = len(c.Addrs[types.Shard(s)-1])

	baseip_file, err := os.Open(filepath.Join(path, *baseIpsFile))
	if err != nil {
		log.Fatal(err)
	}
	defer baseip_file.Close()

	scanner2 := bufio.NewScanner(baseip_file)
	i = 0
	for scanner2.Scan() {
		shard := types.Shard(i)
		addr := "tcp://" + scanner2.Text() + ":"
		_, exist := c.Addrs[shard]
		if !exist {
			c.Addrs[shard] = make(map[identity.NodeID]string)
		}
		c.Addrs[shard][identity.NewNodeID(0)] = addr
		i++
	}
}

// Load loads configuration from Configuration file in JSON format
func (c *Config) LoadBaseShard() {
	// load ips
	ip_file, err := os.Open(filepath.Join(path, *baseIpsFile))
	if err != nil {
		fmt.Println(err)
	}
	defer ip_file.Close()

	scanner := bufio.NewScanner(ip_file)

	i := len(c.HTTPAddrs) + 1
	c.Addrs[0] = make(map[identity.NodeID]string)
	for scanner.Scan() {
		id := identity.NewNodeID(i)
		port := strconv.Itoa(3734 + i)
		addr := "tcp://" + scanner.Text() + ":" + port
		portHttp := strconv.Itoa(8069 + i)
		addrHttp := "http://" + scanner.Text() + ":" + portHttp
		c.Addrs[0][id] = addr
		// shard := c.GetShardNumOfId(id)
		// c.Addrs[shard][id] = addr
		c.HTTPAddrs[id] = addrHttp
		i++
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
	}

	c.nBase = len(c.Addrs[0])
}

func (c Config) GetShardNumOfId(id identity.NodeID) types.Shard {
	if _, exist := c.Addrs[0][id]; exist { // base shard
		return 0
	}
	return types.Shard((id.Node()-1)/(c.NPerShard()) + 1)
}

// Save saves configuration to file in JSON format
func (c Config) Save() error {
	file, err := os.Create(*configFile)
	if err != nil {
		return err
	}
	encoder := json.NewEncoder(file)
	return encoder.Encode(c)
}

func (c Config) IsByzantine(id identity.NodeID) bool {
	return c.ByzNo >= id.Node()
}
